#include <stdio.h>
#include <string.h>
#include <stdlib.h>


#define M 10 
#define N 10 
///////////////////


int Print();
int Findwork();


int S[N][M]={ 
{1,1,1,1,1,1,1,1,1,1}, 
{1,0,0,1,0,0,0,1,0,1},
{1,0,0,1,0,0,0,1,0,1},
{1,0,0,0,0,1,1,0,0,1},
{1,0,1,1,1,0,0,0,0,1},
{1,0,0,0,1,0,0,0,0,1},
{1,0,1,0,0,0,1,0,0,1},
{1,0,1,1,1,0,1,1,0,1},
{1,1,0,0,0,0,0,0,0,1},
{1,1,1,1,1,1,1,1,1,1},
};


struct road
{
int x,y,d;
}lj[100],temp[100];


int num=0;


//////////////////////////////////////////////


int main()
{
Print();
Findwork();
Print();
return 0;
}


int Findwork()
{
int top=0;
int x;
int y;
int d = -1;
int find = 0;//d为设置方向，上下左右。find为设置找不找得到路
int min=10000;


int s_x,s_y;
printf("请输入起点：X X\n");
scanf("%d %d",&s_x,&s_y);




int e_x,e_y;
printf("请输入终点：X X\n");
scanf("%d %d",&e_x,&e_y);


lj[top].x=s_x;
lj[top].y=s_y;
S[s_x][s_y] = -1;

while(top>-1)
{
if(lj[top].x==e_x && lj[top].y==e_y)
{
if(min > top)
{
min = top;
for(num=0;num<=top;num++)
{
temp[num].d=lj[num].d;
temp[num].x=lj[num].x;
temp[num].y=lj[num].y;
}
}
}


while(d < 4 && find == 0)
{
d++;
switch(d)
{
case 0://方向为上
x=lj[top].x-1;
y=lj[top].y;
break;
case 1://方向为右
x=lj[top].x;
y=lj[top].y+1;
break;
case 2://方向为下
x=lj[top].x+1;
y=lj[top].y;
break;
case 3://方向为左
x=lj[top].x;
y=lj[top].y-1;
}
if(S[x][y] == 0)
{
find = 1;
}
}
if(find == 1)//判断是否找得到,1为找得到
{ 
lj[top].d = d;
top++;
lj[top].x = x;
lj[top].y = y;
d = -1;
find = 0;  //重新调整方向
S[x][y] = -1;
}
else //找不到的话退栈
{
S[lj[top].x][lj[top].y] = 0;
top--;
d = lj[top].d;
}
}
return 0;
}


int Print()
{
int i,j;


if(0 != num)
{
for(i=0;i<num;i++)
{
S[temp[i].x][temp[i].y] = 3;
}
}


for(i=0;i<N;i++)
{
for(j=0;j<M;j++)
{
if(S[i][j] == 0)
printf("□");
if(S[i][j] == 1)
printf("■");
if(S[i][j] == 3)
printf("⊙");
}
printf("\n");
}
return 0;
}
